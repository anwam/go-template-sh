package server

import (
	"context"
	"fmt"
	"net/http"
	"time"

	"{{.ModulePath}}/internal/config"
	"{{.ModulePath}}/internal/handlers"
	"{{.ModulePath}}/internal/middleware"
	"{{.ModulePath}}/internal/observability"
)

type Server struct {
	httpServer *http.Server
	config     *config.Config
	obs        *observability.Observability
}

func New(cfg *config.Config, obs *observability.Observability) (*Server, error) {
	s := &Server{
		config: cfg,
		obs:    obs,
	}

	mux := http.NewServeMux()
	
	handler := handlers.NewHandler(cfg, obs)
	
	mux.HandleFunc("/health", handler.Health)
	mux.HandleFunc("/ready", handler.Ready)
	mux.HandleFunc("/", handler.Index)
{{- if .EnableMetrics}}
	mux.Handle("/metrics", obs.MetricsHandler())
{{- end}}

	var h http.Handler = mux
	h = middleware.RequestID(h)
	h = middleware.Logger(h, obs.Logger)
	h = middleware.Recoverer(h, obs.Logger)
{{- if .EnableTracing}}
	h = middleware.Tracing(h, obs.TracerProvider)
{{- end}}

	s.httpServer = &http.Server{
		Addr:         ":" + {{.PortRef}},
		Handler:      h,
		ReadTimeout:  15 * time.Second,
		WriteTimeout: 15 * time.Second,
		IdleTimeout:  60 * time.Second,
	}

	return s, nil
}

func (s *Server) Start() error {
	return s.httpServer.ListenAndServe()
}

func (s *Server) Shutdown(ctx context.Context) error {
	return s.httpServer.Shutdown(ctx)
}
